# Практикум #2
## Какво научихме предният път?
* Въведенеие в курса
* Основни понятия
* Синтаксис и семантика на С++
* Основни елементи в езика С++
* Типове данни
* Основни операции с типове данни
* Как да създадем проект в среда за програмиране
    * Visual Studio
    * Visual Studio Code
## Какво ще научим днес?
* Булеви изрази
* Блок {}, видимост на данни
* if конструкции
* Конструкция ?:
* switch конструкция

## Булеви изрази (Boolean expressions)
### Едно условие
Както видяхме в предното упражнение, когато искаме да проверим **дали дадено нещо е истина или не**, използваме типа **bool** в различни булеви изрази. Видяхме също, че операторите за сравнение връщат булева (логическа) стойност, но с тях може да се сравнява **само едно условие**. Например, ако искаме да проверим дали две числа са равни, можем директно да изведем резултата от сравнението.
```c++     
     int x = 5;
     int y = 3;
     cout << x == y; // 0
     cout << x >= y; // 1
     cout << x != y; // 1
```
### Няколко условия
 Например, ако закъсняваме за УП, то или сме изпуснали автобуса, или се мотаем пред ФМИ, или си пускаме билета за 6/49. В тези случаи, **комбиниранраме различни булеви изрази в по-голям израз**, като се интересуваме от неговия резултат. За да комбинираме използваме **конюнкция(логическо-И)** и **дизюнкция(логическо-ИЛИ)**. Опитайте се да познаете резултата от следните изрази:
```c++
   int x = 5;
   int y = 4;
   int z = x;
   
   cout << (x == z) && (y < x) && (y != z);
   cout << !(z == y) || (x != y) || (x <= z);
```
Можем да комбинираме като използваме различни логически оператори. Опитайте се да отгатнете отговора:
```
   (true && true) || false                                                    
   (false && true) || true
   (false && true) || false || true 
   (5 > 6 || 4 > 3) && (7 > 8)
   !(7 > 6 || 3 > 4)
```
Но смесването им, не е произволно. Тези оператори имат **приоритет**, както събирането и умножението в математиката. **Логическото-И има по-висок приоритет от логическото-ИЛИ**, така че логическите-И оператори ще бъдат оценявани преди логическите-ИЛИ оператори. Например изрази като **value1 || value2 && value3** се оценява като **value1 || (value2 && value3)**, a не като **(value1 || value2) && value3**. 
### NB!
#### При смесване на логически-И и логически-ИЛИ оператори в един и същ израз е добра практика изрично да се посочат операндите на всеки оператор. Това помага да се предотвратят грешките с приотитета, прави кода ви по-лесен за четене и ясно дефинира как сте възнамерявали да оценявате израза. Например, вместо да напишете value1 && value2 || value3 && value4, по-добре напишете (value1 && value2) || (value3 && value4).

#### Закони на Де Морган - логическо-НЕ
Много програмисти правят грешката да мислят, че **!(X && Y) е същото нещо като !X && !Y**. За съжаление обаче, не можете да "използвате" логическото-НЕ по този начин.

Законите на **Де Морган** ни казват как трябва да се преобразуват логическите изрази в тези случаи:

    !(X && Y) е еквивалентно на !X || !Y
    !(X || Y) е еквивалентно на !X && !Y

**С други думи, когато използвате логическo-НЕ, трябва да обърнете логическoто-И към логическо-ИЛИ, и обратно!**

## Блок {} (Block), видимост на данни (Scope)
Блок в програма ще наричаме парчета код които са заградени с { <код> }. Конвенцията за писане изисква новите редове след отварящата скоба - { да започват навътре от предходния ред (в общия случай с една табулация място).  
```c++
{
	std::cout << "One tab inside" << std::endl;
}
```

**Видимост на променливите**, наричаме частта от програмата където можем да **достъпим** дадените променливи. Видимостта, спрямо това как я разглеждаме, можем да я разделим в 3 категории:
 - Вътре във функция или блок, се нарича локална променлива
 - В дефиниция на функция - нарича се формален параметър (ще го разгледаме подробно скоро) 
 - Вън от всички функции, тогава се нарича глобална променлива

**Локалните променливи са видими само в конкретния блок в който са декларирани и във всеки негов подблок.**
**Глобалните променливи са дефинирани извън всички функции, обикновено най - отгоре в програмата. Те могат да бъдат достъпени от всички блокове в програмата.**

Извод: **Избягвайте използването на глобални променливи, ако е възможно! Ако трябва да ги използвате, ги използвайте разумно и предпазливо.** 

```c++
#include<iostream>

// Глобални променливи
bool check;

int main()
{
	// Локални променливи
	int age = 19, fn = 56789;

	std::cout << age;

	{
		std::cout << " " << fn;
	}
	
	check = true;
	return 0;
}
```

## if конструкции (if-statement)
Контролирането потока на програмата, взимането на решение **кога дадени фрагменти да се изпълнят и кога не**, е важно умение за всеки програмист. За това умение се използват различни инструменти. Един такъв инструмент е **условният оператор**, той проверява **дали дадено условие е изпълнено и спрямо този резултат изпълнява зададено следствие** от програмистта. Условният оператор има две основни конструкции(форми): **кратка и пълна.**

### Кратка форма на if
Синтаксис:
```c++
if (<булев_израз>)
{
	// ...
	// блок от операции, които ще бъдат изпълнени
	// ...
}
```

Семантика: Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява блокът от операции, ако върнатият резултат е false блокът се пропуска, т.е. няма да се изпълни нищо. 

```c++
#include <iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;
	
	if (age < ALLOW_AGE) 
		std::cout << "Drink denied" << std::endl;

	return 0;
}
```

### Пълна форма на if
Синтаксис:
```c++
if (<булев_израз>)
{
	// ...
	// блок от операции, които ще бъдат изпълнени
	// ...
}
else
{
	// ...
	// блок от операции, които ще бъдат изпълнени 
}
```

Семантика: Проверява се резултатът от <булев_израз>, ако върнатата стойност е true тогава се изпълнява първият блок от операции, ако върнатият резултат е false - вторият блок. 

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 16;
	
	if (age < ALLOW_AGE)
	{ 
		std::cout << "Drink denied" << std::endl;
	}	
	else
	{
		std::cout << "Drink permitted" << std::endl;
	} 

	return 0;
}
```

#### Вложена форма(Nested form)

```c++
#include<iostream>

int main()
{
	int number = 15;
	
	if (number % 3 == 0)
	{
		if (!(number % 5))
			std::cout << "Divided by 3 and 5" << std::endl;
		else
			std::cout << "Divided by 3 but not by 5" << std::endl;
	}
	
	return 0;
}
```
### Други форми - if-else-if
Синтаксис и семантика:
```c++
if ( <булев_израз> ) 
{
	// ...
  	// Ако <булев_израз> е оценен с true, ще се изпълни този блок с операции
  	// ...
}
else if ( <друг_булев_израз> ) 
{
  	// ...
  	// Ако <друг_булев_израз> е оценен с true И <булев_израз> е оценен с false, 
  	// тогава ще се изпълни този блок с операции
  	// ...
}
else // тази клауза не е задължителна
{
  	// ...
  	// ще се изпълни този блок, ако <булев_израз> И <друг_булев_израз> са оценени с false
  	// ...
}
```

```c++
#include<iostream>

int main()
{
	int a = 19;
	if (a % 2 == 0)
	{
	    std::cout << "divided by 2" << std::endl;
	}
	else if (a % 3 == 0)
	{
		std::cout << "divided by 3" << std::endl;
	}
	else
	{
	      std::cout << "Not divided by 2 and 3" << std::endl;
	}

	return 0;
}
```
## Конструкция ?: (Ternary operator)
?: е форма която наподобява конструкцията if - else. Формално ще наричаме оператора ?: **тернарен оператор**.

Синтаксис: 
```c++
<булев_израз> ? <оператор_при_истина> : <оператор_при_лъжа>
```
Семантика: 
Изчислява се булевият израз, след което се изпълнява при:
 - върнат резултат истина (true) - изпълнява се операторът след ?
 - върнат резултат лъжа (false) - изпълнява се операторът след :

```c++
#include<iostream>

int main()
{
	const int ALLOW_AGE = 18;
	int age = 19;

	std::cout << (age < ALLOW_AGE ? "Drink denied" : "Drink permitted") << std::endl;
	
	return 0; 
}
```

Кога е удобен?

## Оператор switch (Switch statement)
Операторът **switch** позволява тестването на дадена променлива за равенство измежду списък от стойностти. Всяка стойност за проверка се нарича **случай (case).**

Синтаксис:
```c++
switch(<израз|стойност>)
{
	case <стойност_за_проверка>: <операции_за_изпълнение>; break; // break; не е задължително 
	...
	case <стойност_за_проверка>: <операции_за_изпълнение>; break;
	
	default: <операции_за_изпълнение>; break;
}
```
Семантика: Подаваме дадена стойност като параметът на switch, след което се проверява в кой случай стойността от този параметър ще съвпадне по стойност с някоя стойност за проверка, при което се изпълнява операциите подадени към този случай. Ако никоя стойност не съвпадне с подадената се изпълнява случаят default.

### Допълнителни правила:
 * може да имате **неограничен брой случаи (case)**, като трябва за всеки един да дадете стойност по която да се проверява;
 * стойносттите, по които проверяваме, трябва да бъдат **от същия тип** както подадената за проверка; 
 * при откриване на съвпадение **се изпълняват подадените операции до срещане на оператор break**, т.е ако е влезнал във втория case и няма break в него, ще се изпълнят всички оператори в останалите case-ове до достигане на оператор break;
 * при стигане до break, изпълнението на оператора switch се **прекратява и продължава изпълнението на програмата** след него;
 * default е **опционален**, т.е не е от задължителния синтаксис на оператора switch. Той се използва когато никой от изброените условия не се е изпълнило и искаме да отбележим това;
```c++
#include <iostream>
 
int main () {
   // local variable declaration:
   char grade = 'D';

   switch(grade) {
      case 'A' :
         std::cout << "Excellent!" << std::endl; 
         break;
      case 'B' :
      case 'C' :
         std::cout << "Well done" << std::endl;
         break;
      case 'D' :
         std::cout << "You passed" << std::endl;
         break;
      case 'F' :
         std::cout << "Better try again" << std::endl;
         break;
      default :
         std::cout << "Invalid grade" << std::endl;
   }
   std::cout << "Your grade is: " << grade << std::endl;
 
   return 0;
}
```